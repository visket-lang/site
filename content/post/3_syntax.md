---
title: "3. Syntax"
date: 2020-03-13T01:18:49+09:00
sec: 3
---

## 予約語

以下のキーワードは予約されているため、名前に使用できません。

```
fun struct module import
include var return if else
while for in new ref val
```

## 変数

グローバル変数とローカル変数が使用できます。関数の外で宣言した場合にはグローバル変数として、関数の中で宣言した場合にはローカル変数として扱われます。

初期値を指定しなかった場合にもデフォルトでゼロ初期化が行われます。

変数の宣言は以下のように行います。

```kotlin
// 変数"i"をint型で宣言する
// 同時に0で初期化が行われる
var i: int

// 変数"i"をint型で宣言、10で初期化する
var i: int = 10

// 初期値を指定する場合は型名を省略できる
var i = 10
```

`var`の代わりに`val`を使用することで定数として宣言できます。


```kotlin
// ok
var i = 10
i = 0

// ng
val i = 10
i = 0
```

## ファイルの分割

`import`文を使用することで一部の処理を他のファイルに記述できます。

`import`文の対象として指定できるのはファイルのみで、モジュール単位・関数単位でのインポートはできません。

```kotlin
// カレントディレクトリの"std.sl"をインポートする
import "std"
```

## 文

### 関数

関数は以下の構文によって宣言できます。

オーバーロードが未実装であるため同じ名前の関数は同時に宣言できません。同じ名前の関数を使用したい場合には[モジュールについての説明](#モジュール)を参照してください。

```kotlin
// 何もしない関数
fun i_am_a_neet() {
}

// int型を２つ引数にとりint型の値を返す関数"add"を宣言する
fun add(a: int, b: int): int {
  return a + b
}

// 引数で同じ型が続く場合は省略できる
fun add(a, b: int): int {
  return a + b
}
```

デフォルトでは値渡しが用いられますが、キーワード`ref`を使用することで参照渡しが可能です。
```kotlin
// 値渡し
fun clear(i: int) {
  i = 0
}
fun main() {
  var i = 1
  clear(i)
  i // 1
}
```

```kotlin
// 参照渡し
fun clear(ref i: int) {
  i = 0
}

fun main() {
  var i = 1
  clear(i)
  i // 0
}
```

### 構造体

構造体は以下の構文によって宣言できます。

```go
// "Name", "Sex", "Age"をメンバに持つ構造体"Person"を宣言する
struct Person {
  Name: string
  Sex: string
  Age: int
}
```

宣言した構造体は基本型と同じように扱うことができ、メンバへのアクセスは`.`演算子によって行います。基本的な操作を以下に示します。

```kotlin
// インスタンスの作成
var person: Person

// メンバへの代入
person.Name = "John"

// メンバの参照
person.Name

fun greet(person: Person) {
  println(person.Name)
}
```

また、構造体はメンバ関数を持つことができませんが、後に説明する [UFCS](#ufcs) を使用することで擬似的なメンバ関数を宣言できます。

### モジュール

関数の宣言は原則としてトップレベルの名前空間で行われるため、関数名が衝突するする場合があります。そのような場合にモジュールを使用できます。

ファイル単位で自動的にモジュールが設定されることはなく、モジュールの使用には明示的な宣言が必要となります。

モジュールのネストはできません。

構文は以下の通りです。

```go
// 関数"abs", "cos"を持つモジュール"Math"を宣言する
module Math {
  fun abs(x: int): int {
    // (略)
  }

  fun cos(x: float): float {
    // (略)
  }
}
```

モジュール内の関数を呼び出す際は`::`演算子を使用します。

```go
Math::abs(10) //10
Math::abs(-35) // 35
```

### if

条件式を評価しその結果によって分岐します。条件式は bool 型の値を返すものである必要があります。
括弧は必要ありません。

```kotlin
var i = 1

if i > 0 {
  i = 0
} else if i == 0 {
  i = 1
} else {
  i = 2
}

i // 0
```

### while

条件が満たされている間処理を繰り返し実行します。

```kotlin
// 0から9まで10回ループする
var i = 0
while i < 10 {
  i += 1
}
```

### for

C 言語や Java などで使用される古典的な for 文が使用できます。

```kotlin
// 0から9まで10回ループする
for var i = 0; i < 10; i += 1 {

}

// 7h15 15 4 br0w53r cr45h3r
for ;; {}
```

また、 int 型のループについては Ruby-like の構文が使用できます。
```kotlin
// 0から9まで10回ループする
for i in 0..9 {

}
```

## 式

### 算術演算

Visket では以下の算術演算をサポートしています。

- +: 加算
- -: 減算
- *: 乗算
- /: 除算
- %: 剰余

### 関係演算子

Visket では以下の論理演算をサポートしています。

- ==: 等しい
- !=: 等しくない
- < : より小さい
- <=: 以下
- \> : より大きい
- \>=: 以上

これらの演算は常に`false`か`true`の値を返します。


### 関数呼び出し

関数の呼び出しより前に関数を宣言する必要はありません。呼び出しより後に関数が宣言される場合にも問題なく呼び出しを行うことができます。

```kotlin
fun main() {
  do_nothing() // ok
}

fun do_nothing() {}
```

#### UFCS

UFCS による関数呼び出しに対応しています。

```kotlin
fun add(a, b: int): int {
  return a + b
}

// 呼び出し例
1.add(1) // 2

var i = 10
i.add(5) // 15
```

この仕組みは関数の呼び出しがネストするときや、擬似的なメンバ関数を宣言したいときに活用できます。

```kotlin
fun add(a, b: int): int {
  return a + b
}

// 以下は同じ意味を持つ
add(add(i, 2), 3)
i.add(2).add(3)
```
